#!/usr/bin/env python
# coding=utf8

import ConfigParser
import grp
import os
import pwd
import subprocess
import sys


class ServiceUnit(object):
    def __init__(self, script_file):
        self.parser = ConfigParser.SafeConfigParser()
        self.parser.read(script_file)
        self.unit_name = os.path.basename(script_file)
        pid_fname = '/var/run/{0}.pid'.format(self.unit_name)
        self.pid_fname = self._get('PIDFile', pid_fname)
        pid_dir = os.path.dirname(self.pid_fname)
        if not os.path.isdir(pid_dir):
            os.mkdir(pid_dir)
        self.type_ = self._get('Type', 'simple')
        self.environ = os.environ.copy()

    def _set_user(self):
        """Change to the user specified in the service file"""
        try:
            user = self._get('User')
        except ValueError:
            return

        if user.isdigit():
            pwd_entry = pwd.getpwuid(user)
        else:
            pwd_entry = pwd.getpwnam(user)
        self.environ['HOME'] = pw_entry.pw_dir
        self.environ['LOGNAME'] = pw_entry.pw_name
        self.environ['USER'] = pw_entry.pw_name
        self.environ['SHELL'] = pw_entry.pw_shell

        group = self._get('Group', pwd_entry.pwd_gid)
        if group.isdigit():
            grp_entry = grp.getgrgid(group)
        else:
            grp_entry = grp.getgrgid(group)
        os.setgid(grp_entry.gr_gid)
        os.setuid(pwd_entry.pwd_uid)

    def _get(self, name, default=None):
        """Grab a [Service] section value, or a default if not present."""
        try:
            value = self.parser.get('Service', name)
        except ConfigParser.Error:
            if default:
                value = default
            else:
                raise ValueError
        return value

    def _exec(self, action):
        """Executes the given action and returns the Popen object"""
        proc = subprocess.Popen(action, shell=True, env=self.environ,
                                preexec_fn=self._set_user, )
        return proc

    def _exec_with_pid(self, action):
        """Same as _exec, but sets $MAINPID first"""
        self.environ['MAINPID'] = self.get_pid()
        return self._exec(action)

    def get_pid(self):
        with open(self.pid_fname) as pid_file:
            pid = pid_file.readline()
        return pid.strip()

    # # # # LSB standard actions # # # #

    def start(self):
        action = self._get('ExecStart')
        proc = self._exec(action)
        with open(self.pid_fname, 'w') as pid_file:
            pid_file.write(str(proc.pid))

    def stop(self):
        action = self._get('ExecStop')
        _exec_with_pid(action)

    def restart(self):
        self.stop()
        self.start()

    def reload_(self):
        action = self._get('ExecReload')
        _exec_with_pid(action)

    def force_reload(self):
        try:
            action = self._get('ExecReload')
            _exec_with_pid(action)
        except ValueError:
            self.stop()
            self.start()

    def status(self):
        # TODO exit(2) if /var/lock file exists?
        try:
            pid = self.get_pid()
        except IOError:
            exit = 3
        else:
            try:
                os.kill(int(pid))
            except OSError:
                exit = 1
            else:
                exit = 0
        if exit == 0:
            print('Service {} running with PID {}'.format(self.unit_name, pid))
        else:
            print('Service {} not running'.format(self.unit_name))


def main(argv=sys.argv):
    if len(argv) != 3:
        raise ValueError
    _, script_file, action = argv
    unit = ServiceUnit(script_file)
    if action == 'start':
        unit.start()
    elif action == 'stop':
        unit.stop()
    elif action == 'restart':
        unit.restart()
    elif action == 'reload':
        unit.reload_()
    elif action == 'force-reload':
        unit.force_reload()
    elif action == 'status':
        unit.status()
    else:
        raise ValueError

if __name__ == '__main__':
    main()
